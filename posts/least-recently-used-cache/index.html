<!doctype html><html lang=en-us><head><meta charset=utf-8><meta content="Jeff’s note" name=apple-mobile-web-app-title><meta content="Algorithm,Data Structure" name=keywords><meta content="#0d6efd" name=theme-color><meta content="width=device-width,initial-scale=1" name=viewport><meta property="og:url" content="https://chienfuchen32.github.io/posts/least-recently-used-cache/"><meta property="og:site_name" content="Jeff's note"><meta property="og:title" content="Least Recently Used  Cache"><meta property="og:description" content="Purpose TODO
Example from LeetCode 146. LRU Cache problem link Implementation TODO commemt
class Node: def __init__(self, key, value, prev=None, nxt=None): self.key = key self.value = value self.prev = prev self.next = nxt class DoubleLinkList: def __init__(self): self.head = None self.tail = None self.length = 0 def add_node_to_tail(self, node: Node) -> None: self.length += 1 if self.head is None: self.head = node return if self.tail is None: self.tail = node self.tail.prev = self.head self.head.next = self.tail return self.tail.next = node node.prev = self.tail self.tail = node def remove_node_from_head(self) -> int: self.length -= 1 old_key = self.head.key self.head = self.head.next if self.head is not None: self.head.prev = None return old_key def remove_node_from_node(self, node) -> None: self.length -= 1 if node.prev is not None: node.prev.next = node.next if node.next is not None: node.next.prev = node.prev if node == self.tail: if self.tail.prev is not None: self.tail.prev.next = None self.tail = self.tail.prev if node == self.head: if self.head.next is not None: self.head.next.prev = None self.head = self.head.next def print_all_node(self) -> None: ptr = self.head while ptr is not None: ptr = ptr.next class LRUCache: def __init__(self, capacity: int): self.cache = {} # {key: Node} self.link_list = DoubleLinkList() self.capacity = capacity def get(self, key: int) -> int: if self.cache.get(key, None) is not None: node = self.cache[key] value = node.value new_node = Node(key, value) self.link_list.remove_node_from_node(node) self.cache[key] = new_node self.link_list.add_node_to_tail(new_node) return value return -1 def put(self, key: int, value: int) -> None: if self.cache.get(key, None) is not None: node = self.cache[key] del self.cache[key] self.link_list.remove_node_from_node(node) else: if self.link_list.length >= self.capacity: head_key = self.link_list.remove_node_from_head() del self.cache[head_key] new_node = Node(key, value) self.cache[key] = new_node self.link_list.add_node_to_tail(new_node)"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-31T20:10:53+08:00"><meta property="article:modified_time" content="2023-05-31T20:10:53+08:00"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Data Structure"><meta name=twitter:card content="summary"><meta name=twitter:title content="Least Recently Used  Cache"><meta name=twitter:description content="Purpose TODO
Example from LeetCode 146. LRU Cache problem link Implementation TODO commemt
class Node: def __init__(self, key, value, prev=None, nxt=None): self.key = key self.value = value self.prev = prev self.next = nxt class DoubleLinkList: def __init__(self): self.head = None self.tail = None self.length = 0 def add_node_to_tail(self, node: Node) -> None: self.length += 1 if self.head is None: self.head = node return if self.tail is None: self.tail = node self.tail.prev = self.head self.head.next = self.tail return self.tail.next = node node.prev = self.tail self.tail = node def remove_node_from_head(self) -> int: self.length -= 1 old_key = self.head.key self.head = self.head.next if self.head is not None: self.head.prev = None return old_key def remove_node_from_node(self, node) -> None: self.length -= 1 if node.prev is not None: node.prev.next = node.next if node.next is not None: node.next.prev = node.prev if node == self.tail: if self.tail.prev is not None: self.tail.prev.next = None self.tail = self.tail.prev if node == self.head: if self.head.next is not None: self.head.next.prev = None self.head = self.head.next def print_all_node(self) -> None: ptr = self.head while ptr is not None: ptr = ptr.next class LRUCache: def __init__(self, capacity: int): self.cache = {} # {key: Node} self.link_list = DoubleLinkList() self.capacity = capacity def get(self, key: int) -> int: if self.cache.get(key, None) is not None: node = self.cache[key] value = node.value new_node = Node(key, value) self.link_list.remove_node_from_node(node) self.cache[key] = new_node self.link_list.add_node_to_tail(new_node) return value return -1 def put(self, key: int, value: int) -> None: if self.cache.get(key, None) is not None: node = self.cache[key] del self.cache[key] self.link_list.remove_node_from_node(node) else: if self.link_list.length >= self.capacity: head_key = self.link_list.remove_node_from_head() del self.cache[head_key] new_node = Node(key, value) self.cache[key] = new_node self.link_list.add_node_to_tail(new_node)"><title>Least Recently Used Cache · Posts · Jeff’s note</title><link href=/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/favicon-96x96.png rel=icon sizes=96x96 type=image/png><link href=/favicon.ico rel="shortcut icon"><link href=/favicon.svg rel=icon type=image/svg+xml><link href=/web-app-manifest-192x192.png rel=icon type=image/png><link href=/web-app-manifest-512x512.png rel=icon type=image/png><link href=/site.webmanifest rel=manifest><link crossorigin=anonymous href=/css/paige/paige.9201f88eb01a837ce2fa4f827efd954f81ac9d9e.min.3b5b583ef4a5c7e93743e15582585c9c2a7621b8fef6c9c7ad4bac50e4781f05.css integrity="sha256-O1tYPvSlx+k3Q+FVglhcnCp2Ibj+9snHrUusUOR4HwU=" referrerpolicy=no-referrer rel=stylesheet><link crossorigin=anonymous href=/css/paige/bootstrap/paige.37b3fc66686a7163af8180c5fb0fc6ab835321eb.min.55516fbe90a5aad46d6dbc2441c1c193504ee32cb1eef5070ab589c776231a4c.css integrity="sha256-VVFvvpClqtRtbbwkQcHBk1BO4yyx7vUHCrWJx3YjGkw=" referrerpolicy=no-referrer rel=stylesheet><link crossorigin=anonymous href=/css/paige/bootstrap-icons/bootstrap-icons.min.755bbaf60ab33d8f6213c74d33daea2ef5bf22d15245142a27529f8c1d7e80f1.css integrity="sha256-dVu69gqzPY9iE8dNM9rqLvW/ItFSRRQqJ1KfjB1+gPE=" referrerpolicy=no-referrer rel=stylesheet></head><body><div class=container><div class=row><div class="col mt-3" id=paige-site><header id=paige-site-header><div class="display-1 fw-bold text-center" id=paige-site-title><a class="text-body text-decoration-none" href=/>Jeff&rsquo;s note</a></div><nav aria-label=Menu class=paige-row-tall id=paige-site-menu><ul class="align-items-center justify-content-center nav"><li class=nav-item><a class="nav-link text-decoration-underline" href=/about/>About</a></li><li class=nav-item><a aria-current=page class="active fw-bold text-body nav-link text-decoration-underline" href=/posts/>Posts</a></li><li class=nav-item><a class="nav-link text-decoration-underline" href=/tags/>Tags</a></li></ul></nav><nav aria-label=Breadcrumbs class=paige-row-tall id=paige-site-breadcrumbs><div class="d-flex justify-content-center"><ol class="breadcrumb mb-0"><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/posts/>Posts</a></li></ol></div></nav></header><article class="align-items-center d-flex flex-column paige-kind-page paige-status-draft paige-status-unpublished" id=paige-page><header class="mw-100 text-center" id=paige-page-header><h1 class=fw-bold id=paige-page-title>Least Recently Used Cache</h1><div><p class="paige-row-short text-secondary" id=paige-page-keywords><a class="link-secondary paige-page-keyword-tag" href=/tags/algorithm/>Algorithm</a>
·
<a class="link-secondary paige-page-keyword-tag" href=/tags/data-structure/>Data Structure</a></p><p class="paige-row-short text-secondary" id=paige-page-date><time datetime=2023-05-31>May 31, 2023</time></p><p class="paige-row-short text-secondary" id=paige-page-word-count>265 words</p><p class="paige-row-short text-secondary" id=paige-page-reading-time>2 minutes</p></div><div class="align-items-center d-flex flex-column paige-row-tall text-start" id=paige-page-toc><div class="border rounded" style="padding:1rem 2rem 0 1rem"><nav id=TableOfContents><ul><li><a href=#purpose>Purpose</a></li><li><a href=#example-from-leetcode-146-lru-cache>Example from LeetCode 146. LRU Cache</a><ul><li><a href=#implementation>Implementation</a></li></ul></li></ul></nav></div></div></header><main class=mw-100 id=paige-page-content><h2 class=h5 id=purpose><a href=#purpose style=color:rgba(var(--bs-body-color-rgb),var(--bs-text-opacity));text-decoration:none>Purpose</a></h2><p>TODO</p><h2 class=h5 id=example-from-leetcode-146-lru-cache><a href=#example-from-leetcode-146-lru-cache style=color:rgba(var(--bs-body-color-rgb),var(--bs-text-opacity));text-decoration:none>Example from LeetCode 146. LRU Cache</a></h2><p><a href=https://leetcode.com/problems/lru-cache/ rel=external>problem link</a></p><h3 class=h6 id=implementation><a href=#implementation style=color:rgba(var(--bs-body-color-rgb),var(--bs-text-opacity));text-decoration:none>Implementation</a></h3><p>TODO commemt</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#00f>class</span> <span style=color:#2b91af>Node</span>:
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> __init__(self, key, value, prev=<span style=color:#00f>None</span>, nxt=<span style=color:#00f>None</span>):
</span></span><span style=display:flex><span>        self.key = key
</span></span><span style=display:flex><span>        self.value = value
</span></span><span style=display:flex><span>        self.prev = prev
</span></span><span style=display:flex><span>        self.next = nxt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>class</span> <span style=color:#2b91af>DoubleLinkList</span>:
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> __init__(self):
</span></span><span style=display:flex><span>        self.head = <span style=color:#00f>None</span>
</span></span><span style=display:flex><span>        self.tail = <span style=color:#00f>None</span>
</span></span><span style=display:flex><span>        self.length = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> add_node_to_tail(self, node: Node) -&gt; <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>        self.length += 1
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> self.head <span style=color:#00f>is</span> <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>            self.head = node
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span> 
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> self.tail <span style=color:#00f>is</span> <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>            self.tail = node
</span></span><span style=display:flex><span>            self.tail.prev = self.head
</span></span><span style=display:flex><span>            self.head.next = self.tail
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span>
</span></span><span style=display:flex><span>        self.tail.next = node
</span></span><span style=display:flex><span>        node.prev = self.tail
</span></span><span style=display:flex><span>        self.tail = node
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> remove_node_from_head(self) -&gt; int:
</span></span><span style=display:flex><span>        self.length -= 1
</span></span><span style=display:flex><span>        old_key = self.head.key
</span></span><span style=display:flex><span>        self.head = self.head.next
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> self.head <span style=color:#00f>is</span> <span style=color:#00f>not</span> <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>            self.head.prev = <span style=color:#00f>None</span>
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> old_key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> remove_node_from_node(self, node) -&gt; <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>        self.length -= 1
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> node.prev <span style=color:#00f>is</span> <span style=color:#00f>not</span> <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>            node.prev.next = node.next
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> node.next <span style=color:#00f>is</span> <span style=color:#00f>not</span> <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>            node.next.prev = node.prev
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> node == self.tail:
</span></span><span style=display:flex><span>            <span style=color:#00f>if</span> self.tail.prev <span style=color:#00f>is</span> <span style=color:#00f>not</span> <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>                self.tail.prev.next = <span style=color:#00f>None</span>
</span></span><span style=display:flex><span>            self.tail = self.tail.prev
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> node == self.head:
</span></span><span style=display:flex><span>            <span style=color:#00f>if</span> self.head.next <span style=color:#00f>is</span> <span style=color:#00f>not</span> <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>                self.head.next.prev = <span style=color:#00f>None</span>
</span></span><span style=display:flex><span>            self.head = self.head.next
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> print_all_node(self) -&gt; <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>        ptr = self.head
</span></span><span style=display:flex><span>        <span style=color:#00f>while</span> ptr <span style=color:#00f>is</span> <span style=color:#00f>not</span> <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>            ptr = ptr.next
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>class</span> <span style=color:#2b91af>LRUCache</span>:
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> __init__(self, capacity: int):
</span></span><span style=display:flex><span>        self.cache = {} <span style=color:green># {key: Node}</span>
</span></span><span style=display:flex><span>        self.link_list = DoubleLinkList()
</span></span><span style=display:flex><span>        self.capacity = capacity
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> get(self, key: int) -&gt; int:
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> self.cache.get(key, <span style=color:#00f>None</span>) <span style=color:#00f>is</span> <span style=color:#00f>not</span> <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>            node = self.cache[key]
</span></span><span style=display:flex><span>            value = node.value
</span></span><span style=display:flex><span>            new_node = Node(key, value)
</span></span><span style=display:flex><span>            self.link_list.remove_node_from_node(node)
</span></span><span style=display:flex><span>            self.cache[key] = new_node
</span></span><span style=display:flex><span>            self.link_list.add_node_to_tail(new_node)
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span> value
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> -1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>def</span> put(self, key: int, value: int) -&gt; <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> self.cache.get(key, <span style=color:#00f>None</span>) <span style=color:#00f>is</span> <span style=color:#00f>not</span> <span style=color:#00f>None</span>:
</span></span><span style=display:flex><span>            node = self.cache[key]
</span></span><span style=display:flex><span>            <span style=color:#00f>del</span> self.cache[key]
</span></span><span style=display:flex><span>            self.link_list.remove_node_from_node(node)
</span></span><span style=display:flex><span>        <span style=color:#00f>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#00f>if</span> self.link_list.length &gt;= self.capacity:
</span></span><span style=display:flex><span>                head_key = self.link_list.remove_node_from_head()
</span></span><span style=display:flex><span>                <span style=color:#00f>del</span> self.cache[head_key]
</span></span><span style=display:flex><span>        new_node = Node(key, value)
</span></span><span style=display:flex><span>        self.cache[key] = new_node
</span></span><span style=display:flex><span>        self.link_list.add_node_to_tail(new_node)
</span></span></code></pre></div></main><footer class=mw-100 id=paige-page-footer><div id=paige-page-siblings><div class="paige-row-short text-center text-secondary" id=paige-page-next><a class=link-secondary href=https://chienfuchen32.github.io/posts/how-to-repair-file-system-provided-from-kubernetes-ceph-persistent-volume/>How to Repair File System Provided From Kubernetes Ceph Persistent Volume</a> &#8250;</div><div class="paige-row-short text-center text-secondary" id=paige-page-prev>&#8249; <a class=link-secondary href=https://chienfuchen32.github.io/posts/n-queen-problem/>N Queen Problem</a></div></div></footer></article><footer id=paige-site-footer><p class="paige-row-short text-center text-secondary" id=paige-site-credit><a class="link-secondary text-decoration-none" href=https://github.com/willfaught/paige>Paige Theme</a></p></footer></div></div></div><script crossorigin=anonymous defer integrity="sha256-GdpV5fXTSprZ1he71RUKGZl0E3HtqxFXvbylEdkWmRQ=" referrerpolicy=no-referrer src=/js/paige/bootstrap/bootstrap.bundle.min.19da55e5f5d34a9ad9d617bbd5150a1999741371edab1157bdbca511d9169914.js></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","abstract":" Purpose TODO\nExample from LeetCode 146. LRU Cache problem link Implementation TODO commemt\nclass Node: def __init__(self, key, value, prev=None, nxt=None): self.key = key self.value = value self.prev = prev self.next = nxt class DoubleLinkList: def __init__(self): self.head = None self.tail = None self.length = 0 def add_node_to_tail(self, node: Node) -\u003e None: self.length += 1 if self.head is None: self.head = node return if self.tail is None: self.tail = node self.tail.prev = self.head self.head.next = self.tail return self.tail.next = node node.prev = self.tail self.tail = node def remove_node_from_head(self) -\u003e int: self.length -= 1 old_key = self.head.key self.head = self.head.next if self.head is not None: self.head.prev = None return old_key def remove_node_from_node(self, node) -\u003e None: self.length -= 1 if node.prev is not None: node.prev.next = node.next if node.next is not None: node.next.prev = node.prev if node == self.tail: if self.tail.prev is not None: self.tail.prev.next = None self.tail = self.tail.prev if node == self.head: if self.head.next is not None: self.head.next.prev = None self.head = self.head.next def print_all_node(self) -\u003e None: ptr = self.head while ptr is not None: ptr = ptr.next class LRUCache: def __init__(self, capacity: int): self.cache = {} # {key: Node} self.link_list = DoubleLinkList() self.capacity = capacity def get(self, key: int) -\u003e int: if self.cache.get(key, None) is not None: node = self.cache[key] value = node.value new_node = Node(key, value) self.link_list.remove_node_from_node(node) self.cache[key] = new_node self.link_list.add_node_to_tail(new_node) return value return -1 def put(self, key: int, value: int) -\u003e None: if self.cache.get(key, None) is not None: node = self.cache[key] del self.cache[key] self.link_list.remove_node_from_node(node) else: if self.link_list.length \u003e= self.capacity: head_key = self.link_list.remove_node_from_head() del self.cache[head_key] new_node = Node(key, value) self.cache[key] = new_node self.link_list.add_node_to_tail(new_node) ","articleSection":"Posts","dateCreated":"2023-05-31T20:10:53+08:00","dateModified":"2023-05-31T20:10:53+08:00","headline":"Least Recently Used  Cache","inLanguage":"en-us","keywords":"Algorithm, Data Structure","name":"Least Recently Used  Cache","timeRequired":"PT2M","url":"https://chienfuchen32.github.io/posts/least-recently-used-cache/","wordCount":265}</script><noscript>JavaScript is required</noscript></body></html>